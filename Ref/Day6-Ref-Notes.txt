==========================================


	=> explore about overriding equals() method

	=> Preserve the equality contract when overriding the equals() method

	=> equals() and hashCode() contract

			-> if two objects are same, their hashcode must be same

			-> if two objects have identical hashcode, they may be same

			-> if two objects are unequal, they may have same hashCode



	=> Enumeration / Iterator / ListIterator

	=> List of numbers / strings / date objects and sort it (find natural ordering)

??????	=> how HashSet internally works?

==========================================




	-> Java Basics
	-> java language essentials
		-> data types
		-> decision making
		-> looping
		-> arrays
		-> strings
		-> methods
		-> class and objects
	
Standard libraries/ packages / apis
---------------------------------------------

*=> Collection Framework api
----------------------------------

	-> provides data structures to create dynamically allocated group of objects 
	-> java.util package provides all interfaces, and their implementaion classes



		   Iterable<E> (i)	---> iterator();
		        |
		   Collection<E> (i)
			|
    ----------------------------------------------------------------
    |				|				|
 List<E> (i)  	Set<E> (i)		 Queue <E> (i)
    |				|			 	|
ArrayList<E>    HashSet<E>			-------------------
LinkedList<E>   LinkedHashSet<E>	|		  	  |
Vector<E>		TreeSet<E>		 Deque<E>(i)    BlockingQueue<E>(i)
Stack<E>						    |
						     BlockingDeque<E>(i)


			Map<K,V> (i)
			   |
			HashMap<K,V>
			LinkedHashMap<K,V>
			TreeMap<K,V>
			HashTable<K,V>



Collection<E> interface
-------------------------------
	-> the supermost interface in the collection hierarchy, which describes some common methods

		public boolean add(Object o)
		public boolean addAll(Collection c)
		public boolean remove(Object o)
		public int size()
		public void clear()
		public boolean contains(Object o)
		...
		...

List<E> interface
-----------------------
	-> models a collection objects, which is index based 
	-> allows duplicate elements 
	-> i.e. ArrayList, LinkedList are frequently used implementations of list interface 


Set<E> interface
---------------------
	-> models a collection of unique elements
	-> doesn;t allow duplicates 
	-> i.e. HashSet, LinkedHashSet, Treeset 

Queue<E> interface
------------------------
	-> models a collection fo objects which used FIFO approach 
	-> PriorityQueue, ArrayDeque, etc. 
	

Map<K,V> interface
-----------------------
	-> models a collection of objects stored using 'key-value' pairs 
	-> HashMap, LinkedHashMap, TreeMap, HashTable, etc.
		

========================================================================================



	equals()
		- belongs to Object class 
		- since Object class is the implicit superclass for alll the classes in java, we can override the equals() method in child class
		- the default implementation of equals() method in Object class simply checks if two object references refer to the same 			object
		- all the wrapper classes, String class have already overridden the equals() method

		class Object{

			public boolean equals(Object obj){

			}

		}

		class Employee {

		}

	What is Object class's equals() contract?

		- It is reflexive: for any non-null reference value x, x.equals(x) should return true.
		- It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) 			returns true.
		- It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then 			x.equals(z) should return true.
		- It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true 			or consistently return false, provided no information used in 			equals comparisons on the objects is modified.
			For any non-null reference value x, x.equals(null) should return false.


	What is diff between '==' operator and equals() method 

		-> '==' operator is used to compare primitives while equals() method is ued to check equality of objects
		-> '==' returns true if two references are of same object. 
		-> equals() method depends on the overridden implemention 
		-> for comparing two Strings use equals() method instead of '==' 

	hashCode()
		-> this method belongs to object class 
		-> the hashCode() returns an integer value, generated by a hashing algorithm 
		-> this integer value is derived from the memory address in the heap 
		-> whenver we override the equals() method we must override the hashCode();



	equals() and hashCode() contract

		--> Objects that are equal (according to their equals()), must have same hash code


Object class methods
----------------------------
	public boolean equals(Object obj)
	public int hashCode()



	String class 
	   String s1="ddd"
	   String s2="sss"

		s1.equals(s2)












List<E> interface
------------------------
	-> List is kind of collection, used to create index based collection of objects 
	**-> List allows null and duplicate elements 
	-> a List Collection maintains "order of insertion"
	**-> A List can store only "Objects" / 
	**-> Primivites values cannot be stored in collection, 
			if you want to store primitives values in any Collection, they must be 
			wrapped inside an object of their corresponding ref type (Wrapper classes)



	**=> primitives cannot be stored on any Collection


			Collection {I}
			    |
			  List {I}
			    |
			AbstractList (abstract class)
			    |
	----------------------------------------------------
	    |		    		|			 	 |		
	ArrayList {C}		LinkedList{C}		Vector {C}
					    					 |
					   					    Stack {C}



Implementation classes of List Interface
---------------------------------------------

	1. ArrayList

		-> internally ArrayList uses 'resizable-array' as a data structure 
		-> initial capacity = 10
		-> performance is slow, due to frequent shifting while inserting/removing

	2. LinkedList
		-> internally uses 'double-linked-list' data structure
		-> initial capacity = N/A

	3. Vector 
		-> similar to ArrayList
		-> synchronized (can be used in multithreaded environment)

	4. Stack
		-> similar to ArrayList
		-> synchronized
		-> LIFO approach


Operations on List 
------------------------------

	1. Creating a list 


		//non-generic 
		ArrayList list1 = new ArrayList();
		List list2 = new ArrayList();
		
		
		//generic 
		List<Integer> list3 = new ArrayList<>();
		List<Integer> list3 = new LinkedList<>();

		List<String> names = new ArrayList<>();



	2. Basic operations on list
	--------------------------------------

		a. add an element on a list

			.add(object o)
			.add(int index, object o)
			.addAll(Collection c)

		b. removing element from a list 
	
			.remove(int index);
	
			.remove(object o)
				->note: it uses equals() method to compare the given object 						with all the other object
				-> if you have, a collection of custom objects, make sure that, the equals() 
						is implemented correctly


		c. retrieve element from a list

			Object get(int index)

			E get(int index)

		d. updating elements 

			.set(int index, Object o)



	3. Iterating over a list
	-----------------------------------

		a. using classic for loop 

			for(int i=0; i<list.size(); i++){
				int value = list.get(i);
				sysout(value);
			}

		b. enhanced for loop 

			for(int value : list){
				sysout(value)
			}

		c. using Iterator

			Iterator<Integer> itr = list.iterator();

			while(itr.hasNext()){
				int value = itr.next();
				sysout(value);
			}


	4. Searching an element on a list
	
		boolean contains(object o)
		int indexOf(object o)
		int lastIndexOf(object o)


	5. Sorting a list

		Arrays.sort(array)
		Collections.sort(list)


			*=> internally uses 'compareTo()' to compare two objects 

	6. Copying one list into another

			Collections.copy(dest, src)

	7. Shuffling elements in a list

			Collections.shuffle(list)

	8. converting a list to array / array to list




	ArrayList		LinkedList		Vector			Stack

	ordered	by		ordered	by		ordered	by		ordered	by
	insertion		insertion		insertion		insertion

	nullvalues		nullvalues		nullvalues		nullvalues

	duplicates		duplicates		duplicates		duplicates

	10				N/A				10				10

	resizable		double			resizable		resizable
	array			linked list		array			array

									synchronized	synchronized

Set<E> interface
---------------------------
	-> doesn't allow duplicate elements 


Implemetation classes of set interface
--------------------------------------

	1. HashSet

		-> uses 'hashtable' data structure
		-> doesn't guarantee the order of insertion

	2. LinkedHashSet

		-> uses 'hashtable + double linked list' data structure
		-> maintains order of insertion

	3. TreeSet

		-> uses 'balance tree' data structure
		-> maintains sorted order of elements according to the natural ordering



	
Operations on set
---------------------------

	1. adding element 
	2. removing element 
	3. iterating element 
	4. searching elemnet 	

	*=> whenever we use any hashtable based collection, for storing custom objects, make 			sure you correctly override equals() and hashCode() methods




Comparable interface 
--------------------------

	-> to specify the natural ordering, you can implement Comparable interface


		interface Comparable<E>{
			public abstract int compareTo(Object o)
		}


		class Employee implements Comparable{

			public int compareTo(Object o){
				
			}						

		}

	comparevalue
	--------------------

		>1	: this object is greater than other

		<1	: this object is less than other

	
		=0	: both objects are same


	









	e1		e2		e3		e4		e5
	|		|



	...
	...
	empSet.add(new Employee(...));

		-> this.compareTo(e1)






Comparator interface 
--------------------------
	-> used to create exeternal comparators 

		interface Comparator<E> {
			public abstract int compare(Object o1, Object o2);
		}



		class EmpIdComparator implements Comparator<Employee>{
			//override
			public int compare(Employee e1, Employee e2){
				//logic to compare....
			}
		}


		Set<Employee> empSet = new TreeSet<>(new EmpIdComparator());





















